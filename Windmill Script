# requirements:
# requests==2.31.0
# supabase==2.3.4
# rich==13.7.0
# beautifulsoup4==4.12.2
# python-dotenv==1.0.0
# pandas==2.0.3
# tenacity==8.2.3

"""
XPRESS SEO MASTER - SISTEMA COMPLETO
Script Master Adm Unificado com SerpiAPI + OpenRouter
Modo Gera√ß√£o de Conte√∫do + Modo An√°lise GSC
"""

import requests
import json
import re
from bs4 import BeautifulSoup
import os
from dotenv import load_dotenv
import urllib.parse
import pandas as pd
import logging
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

load_dotenv()

# ============================================================================
# OpenRouter Client V2 - Incorporado para auto-sufici√™ncia no Windmill
# ============================================================================
class OpenRouterClientV2:
    """Cliente OpenRouter otimizado - vers√£o incorporada"""
    
    circuit_open = False
    circuit_last_failure = None
    circuit_threshold = 5
    circuit_timeout = 60
    
    _cache = {}
    _cache_ttl = 300
    
    MODELOS = {
        'geral': 'meta-llama/llama-3.1-8b-instant', # Mais r√°pido para tarefas gerais
        'criativo': 'anthropic/claude-3.5-sonnet',
        'tecnico': 'openai/gpt-4o',
        'traducao': 'openai/gpt-4o-mini', # Usando gpt-4o-mini para tradu√ß√£o
        'analise': 'anthropic/claude-3-opus',
        'conciso': 'openai/gpt-4o-mini', # Novo papel para sa√≠da concisa e de alta qualidade
        'fallback': 'meta-llama/llama-3.1-70b-instruct' # Mantido como fallback robusto
    }
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = 'https://openrouter.ai/api/v1/chat/completions'
        self.headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json',
            'HTTP-Referer': 'https://windmill.dxsdigital.com',
            'X-Title': 'XpressSEO Windmill'
        }
        logger.info("OpenRouter Client V2 inicializado (incorporado)")
    
    def _check_circuit_breaker(self):
        if self.circuit_open:
            if datetime.now() - self.circuit_last_failure < timedelta(seconds=self.circuit_timeout):
                raise Exception("Circuit breaker aberto - OpenRouter temporariamente indispon√≠vel")
            else:
                self.circuit_open = False
                logger.info("Circuit breaker fechado - retentando conex√£o")
    
    def _record_failure(self):
        self.circuit_last_failure = datetime.now()
        self.circuit_open = True
        logger.warning("Circuit breaker aberto devido a falhas consecutivas")
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((requests.RequestException,)),
        reraise=True
    )
    def gerar_conteudo(self, prompt: str, modelo_chave: str = 'geral', temperatura: float = 0.7, 
                      max_tokens: int = 2048, system_prompt: Optional[str] = None) -> Tuple[str, int, str]:
        
        self._check_circuit_breaker()
        
        if not prompt or len(prompt.strip()) < 10:
            raise ValueError("Prompt deve ter pelo menos 10 caracteres")
        
        if modelo_chave not in self.MODELOS:
            raise ValueError(f"Modelo inv√°lido: {modelo_chave}. Dispon√≠veis: {list(self.MODELOS.keys())}")
        
        model_id = self.MODELOS[modelo_chave]
        cache_key = f"{model_id}:{hash(prompt)}:{hash(system_prompt or '')}"
        
        if cache_key in self._cache:
            cache_data = self._cache[cache_key]
            if datetime.now() - cache_data['timestamp'] < timedelta(seconds=self._cache_ttl):
                logger.info(f"Cache hit para prompt: {cache_key[:50]}...")
                return cache_data['response'], cache_data['tokens'], cache_data['modelo_id']
        
        try:
            messages = []
            if system_prompt:
                messages.append({'role': 'system', 'content': system_prompt})
            messages.append({'role': 'user', 'content': prompt})
            
            payload = {
                'model': model_id,
                'messages': messages,
                'temperature': max(0.1, min(1.0, temperatura)),
                'max_tokens': max(100, min(4000, max_tokens))
            }
            
            response = requests.post(
                self.base_url,
                headers=self.headers,
                json=payload,
                timeout=60
            )
            
            if response.status_code != 200:
                logger.error(f"OpenRouter error {response.status_code}: {response.text}")
                self._record_failure()
                raise Exception(f"Erro OpenRouter: {response.status_code} - {response.text}")
            
            result = response.json()
            conteudo = result['choices'][0]['message']['content']
            
            usage = result.get('usage', {})
            tokens = usage.get('total_tokens', 0)
            logger.info(f"OpenRouter: {tokens} tokens usados - Modelo: {model_id}")
            
            self._cache[cache_key] = {
                'response': conteudo,
                'timestamp': datetime.now(),
                'tokens': tokens,
                'modelo_id': model_id
            }
            
            self._limpar_cache_antigo()
            self.circuit_open = False
            
            return conteudo, tokens, model_id
            
        except requests.RequestException as e:
            logger.error(f"Request error: {str(e)}")
            self._record_failure()
            raise
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}")
            raise
    
    def _limpar_cache_antigo(self):
        now = datetime.now()
        keys_to_remove = []
        
        for key, data in self._cache.items():
            if now - data['timestamp'] > timedelta(seconds=self._cache_ttl):
                keys_to_remove.append(key)
        
        for key in keys_to_remove:
            del self._cache[key]
        
        if keys_to_remove:
            logger.info(f"Limpos {len(keys_to_remove)} entradas de cache antigas")
    
    def listar_modelos_disponiveis(self) -> Dict[str, str]:
        return self.MODELOS.copy()
    
    def get_cache_stats(self) -> Dict[str, Any]:
        return {
            'total_entries': len(self._cache),
            'cache_ttl': self._cache_ttl,
            'circuit_status': 'OPEN' if self.circuit_open else 'CLOSED'
        }

# ============================================================================
# XpressSEOMaster - Refatorado para o fluxo de chat do frontend
# ============================================================================

class XpressSEOMaster:
    """Sistema Master Completo SEO para E-commerce Dropshipping"""
    
    def __init__(self, project_id: str, user_id: str, user_message: str, current_step: int,
                 supabase_url: str, supabase_key: str, openrouter_key: str, serpi_api_key: str):
        
        self.project_id = project_id
        self.user_id = user_id
        self.user_message = user_message
        self.current_step = current_step
        self.supabase_url = supabase_url
        self.supabase_key = supabase_key
        self.openrouter_key = openrouter_key
        self.serpi_api_key = serpi_api_key
        self.client = create_client(self.supabase_url, self.supabase_key)
        
        self.openrouter_client = OpenRouterClientV2(api_key=self.openrouter_key)
        
        self.memoria: Dict[str, Any] = {}
        self._load_project_state()
        
        self.modo_operacao = 'geracao_conteudo'
        self.cache_pesquisas = {}
        
        self.glossario_produtos = {
            'rel√≥gio': {'UK': 'wristwatch', 'FR': 'montre', 'ES': 'reloj de pulsera', 'DE': 'Armbanduhr'},
            'bolsa': {'UK': 'handbag', 'FR': 'sac √† main', 'ES': 'bolso de mano', 'DE': 'Handtasche'},
            't√™nis': {'UK': 'trainers', 'FR': 'baskets', 'ES': 'zapatillas deportivas', 'DE': 'Sportschuhe'},
            'camiseta': {'UK': 'T-shirt', 'FR': 't-shirt', 'ES': 'camiseta', 'DE': 'T-Shirt'},
            '√≥culos de sol': {'UK': 'sunglasses', 'FR': 'lunettes de soleil', 'ES': 'gafas de sol', 'DE': 'Sonnenbrille'},
            'jaqueta': {'UK': 'jacket', 'FR': 'veste', 'ES': 'chaqueta', 'DE': 'Jacke'},
            'mochila': {'UK': 'backpack', 'FR': 'sac √† dos', 'ES': 'mochila', 'DE': 'Rucksack'}
        }

    def _load_project_state(self):
        """Carrega o estado do projeto (mem√≥ria) do Supabase."""
        if self.project_id:
            response = self.client.from_('projects').select('extracted_data, current_step, status, ai_state').eq('id', self.project_id).single().execute()
            if response.data:
                project_data = response.data
                if project_data.get('extracted_data'):
                    self.memoria = project_data['extracted_data']
                # A coluna 'ai_state' √© para o frontend, mas podemos us√°-la para carregar o current_step se 'extracted_data' n√£o tiver
                if project_data.get('ai_state') and project_data['ai_state'].get('current_step') is not None:
                    self.current_step = project_data['ai_state']['current_step']
                else:
                    self.current_step = project_data.get('current_step', 0) # Fallback para current_step direto
                
                self.memoria['status_projeto'] = project_data.get('status', 'in_progress')
                logger.info(f"‚úÖ Estado do projeto {self.project_id} carregado. Etapa atual: {self.current_step}")
            else:
                logger.warning(f"‚ö†Ô∏è Projeto {self.project_id} n√£o encontrado ou sem estado. Iniciando com mem√≥ria vazia.")
        else:
            logger.warning("‚ö†Ô∏è Nenhum project_id fornecido. Iniciando com mem√≥ria vazia para novo projeto.")
        
        self.memoria.setdefault('nome_usuario', self.user_id)
        self.memoria.setdefault('nome_site_usuario', "XpressSEO Site")
        self.memoria.setdefault('link_produto', '')
        self.memoria.setdefault('pais_venda', 'Brasil')
        self.memoria.setdefault('dados_extraidos_do_link', {})
        self.memoria.setdefault('palavra_chave_principal', '')
        self.memoria.setdefault('last_ai_message_type', 'text') # Para saber o que a IA enviou por √∫ltimo
        self.memoria.setdefault('last_ai_options', []) # Para guardar op√ß√µes se a IA enviou
        
        for i in range(1, 10):
            self.memoria.setdefault(f'etapa{i}_resultado', '')
            self.memoria.setdefault(f'etapa{i}_escolha', '')
            self.memoria.setdefault(f'etapa{i}_status', 'PENDENTE')
            self.memoria.setdefault(f'etapa{i}_llm_usada', '') # Novo campo
            self.memoria.setdefault(f'etapa{i}_tokens_usados', 0) # Novo campo
        self.memoria.setdefault('etapa7a_resultado', '')
        self.memoria.setdefault('etapa7b_resultado', '')

    def _save_project_state(self, new_status: Optional[str] = None, ai_state_update: Optional[Dict] = None):
        """Salva o estado atual do projeto (mem√≥ria e etapa) no Supabase."""
        if self.project_id:
            update_data = {
                'extracted_data': self.memoria,
                'current_step': self.current_step,
                'updated_at': datetime.now().isoformat()
            }
            if new_status:
                update_data['status'] = new_status
            
            # Atualiza ai_state com o current_step para o frontend
            current_ai_state = ai_state_update if ai_state_update is not None else {}
            current_ai_state['current_step'] = self.current_step
            update_data['ai_state'] = current_ai_state

            response = self.client.from_('projects').update(update_data).eq('id', self.project_id).execute()
            if response.data:
                logger.info(f"üíæ Estado do projeto {self.project_id} salvo no Supabase. Etapa: {self.current_step}")
            else:
                logger.error(f"‚ùå Erro ao salvar estado do projeto {self.project_id}: {response.error}")
        else:
            logger.warning("‚ö†Ô∏è Nenhum project_id para salvar o estado.")

    def _add_chat_message(self, author: str, content: str, metadata: Optional[Dict] = None):
        """Adiciona uma mensagem ao hist√≥rico de chat no Supabase."""
        if self.project_id:
            message_data = {
                'project_id': self.project_id,
                'user_id': self.user_id,
                'author': author,
                'content': content,
                'metadata': metadata or {}
            }
            response = self.client.from_('chat_messages').insert(message_data).execute()
            if response.data:
                logger.info(f"üí¨ Mensagem de {author} adicionada ao chat.")
            else:
                logger.error(f"‚ùå Erro ao adicionar mensagem ao chat: {response.error}")

    def executar_sistema(self, arquivo_upload=None) -> Dict:
        """M√©todo principal que decide entre Modo Gera√ß√£o ou Modo An√°lise GSC e gerencia o fluxo."""
        
        output_messages = []
        
        # Se o projeto est√° completo ou em erro, n√£o processa mais mensagens
        if self.memoria.get('status_projeto') in ['completed', 'error']:
            output_messages.append({
                "type": "text",
                "data": f"O projeto est√° em status '{self.memoria['status_projeto']}'. Inicie um novo projeto para continuar."
            })
            return {"type": "structured_response", "messages": output_messages}

        # L√≥gica para lidar com a mensagem do usu√°rio
        if self.user_message:
            logger.info(f"User message received: {self.user_message}")
            # Tenta processar a mensagem do usu√°rio como uma a√ß√£o
            action_handled = self._handle_user_action(output_messages)
            if action_handled:
                # Se a a√ß√£o foi tratada, o current_step j√° foi atualizado
                # e podemos prosseguir para a pr√≥xima etapa do workflow.
                pass
            else:
                # Se a mensagem do usu√°rio n√£o foi uma a√ß√£o reconhecida,
                # e o current_step √© 0, significa que √© o link inicial.
                if self.current_step == 0:
                    # A mensagem do usu√°rio √© o link do produto
                    self.memoria['link_produto'] = self.user_message
                    self.current_step = 1 # Avan√ßa para a pr√≥xima fase
                    self._save_project_state()
                    output_messages.append({
                        "type": "text",
                        "data": f"‚úÖ Link do produto recebido: {self.memoria['link_produto']}"
                    })
                else:
                    # Mensagem do usu√°rio n√£o reconhecida como a√ß√£o ou link inicial
                    output_messages.append({
                        "type": "text",
                        "data": "Desculpe, n√£o entendi sua mensagem. Por favor, digite 'aprovar' para continuar, 'regenerar' para refazer a etapa, ou o n√∫mero da op√ß√£o desejada."
                    })
                    return {"type": "structured_response", "messages": output_messages}
        
        # Dispatcher principal do workflow
        if self.current_step == 0:
            # Se ainda est√° na etapa 0 e n√£o recebeu o link, pede o link
            output_messages.append({
                "type": "text",
                "data": "Ol√°! Por favor, me forne√ßa o link do produto que voc√™ deseja analisar para come√ßarmos."
            })
            return {"type": "structured_response", "messages": output_messages}
        elif self.current_step == 1:
            return self._fase_1_analise_planejamento(output_messages)
        elif 1 < self.current_step <= 10: # Etapas de 2 a 10 (9 etapas de gera√ß√£o + 1 de tradu√ß√£o/HTML)
            return self._fase_2_execucao_etapas(output_messages)
        elif self.current_step == 11: # Ap√≥s a etapa 10, vai para conclus√£o
            return self._fase_3_conclusao_entrega(output_messages)
        else:
            output_messages.append({
                "type": "error",
                "data": {"message": "Estado do workflow desconhecido. Por favor, inicie uma nova conversa."}
            })
            self._save_project_state(new_status='error')
            return {"type": "structured_response", "messages": output_messages}

    def _handle_user_action(self, output_messages: List[Dict]) -> bool:
        """Processa a mensagem do usu√°rio como uma a√ß√£o (aprovar, selecionar, regenerar)."""
        user_input = self.user_message.strip().lower()
        
        # A√ß√£o de aprova√ß√£o gen√©rica
        if user_input in ['aprovar', 'ok', 'sim', 'continuar']:
            # Se a √∫ltima mensagem da IA foi de op√ß√µes, isso √© um erro
            if self.memoria.get('last_ai_message_type') == 'options':
                output_messages.append({
                    "type": "text",
                    "data": "Por favor, selecione uma das op√ß√µes digitando o n√∫mero correspondente, ou 'regenerar' para novas op√ß√µes."
                })
                return True # A√ß√£o tratada, mas com feedback de erro
            
            # Aprova o resultado da etapa anterior
            # A etapa 9 (Valida√ß√£o T√©cnica) √© a √∫ltima etapa de gera√ß√£o de conte√∫do antes da tradu√ß√£o.
            # Se o current_step √© 10, significa que a etapa 9 foi a √∫ltima a ser gerada.
            if self.current_step == 10: # Etapa 9 (Valida√ß√£o T√©cnica)
                last_step_num = 9
                last_step_result_key = f'etapa{last_step_num}_resultado'
            else: # Para as etapas 1 a 8
                last_step_num = self.current_step - 1
                last_step_result_key = f'etapa{last_step_num}_resultado'
                if last_step_num in [2, 3, 5, 6, 8]: # Etapas que retornam op√ß√µes
                    last_step_result_key = f'etapa{last_step_num}_escolha' # A escolha j√° foi feita na sele√ß√£o de op√ß√£o
            
            if self.memoria.get(last_step_result_key):
                self.memoria[f'etapa{last_step_num}_status'] = 'APROVADO'
                # Se n√£o foi uma etapa de op√ß√µes, o resultado √© a escolha
                if last_step_num not in [2, 3, 5, 6, 8]:
                    self.memoria[f'etapa{last_step_num}_escolha'] = self.memoria[last_step_result_key]
                
                output_messages.append({
                    "type": "text",
                    "data": f"‚úÖ Conte√∫do da Etapa {last_step_num} aprovado!"
                })
                self.current_step += 1 # Avan√ßa para a pr√≥xima etapa
                self._save_project_state()
                return True
            else:
                output_messages.append({
                    "type": "text",
                    "data": "N√£o h√° conte√∫do para aprovar na etapa anterior."
                })
                return True # A√ß√£o tratada, mas com feedback de erro
        
        # A√ß√£o de sele√ß√£o de op√ß√£o (se a √∫ltima mensagem da IA foi de op√ß√µes)
        if self.memoria.get('last_ai_message_type') == 'options' and self.memoria.get('last_ai_options'):
            try:
                selected_number = int(user_input)
                options = self.memoria['last_ai_options']
                selected_option = next((opt for opt in options if opt['number'] == selected_number), None)
                
                if selected_option:
                    # Salva a escolha do usu√°rio para a etapa atual
                    last_step_num = self.current_step - 1
                    self.memoria[f'etapa{last_step_num}_escolha'] = selected_option['content']
                    self.memoria[f'etapa{last_step_num}_status'] = 'APROVADO'
                    output_messages.append({
                        "type": "text",
                        "data": f"‚úÖ Op√ß√£o {selected_number} selecionada para a Etapa {last_step_num}!"
                    })
                    self.current_step += 1 # Avan√ßa para a pr√≥xima etapa
                    self._save_project_state()
                    self.memoria['last_ai_message_type'] = 'text' # Reseta o tipo de mensagem da IA
                    self.memoria['last_ai_options'] = []
                    return True
                else:
                    output_messages.append({
                        "type": "text",
                        "data": "Op√ß√£o inv√°lida. Por favor, digite o n√∫mero de uma das op√ß√µes apresentadas."
                    })
                    return True # A√ß√£o tratada, mas com feedback de erro
            except ValueError:
                pass # N√£o √© um n√∫mero, continua para outras a√ß√µes
        
        # A√ß√£o de regenera√ß√£o
        if user_input == 'regenerar':
            # A etapa a ser regenerada √© sempre a anterior √† current_step
            step_to_regenerate = self.current_step - 1
            if step_to_regenerate < 1:
                output_messages.append({
                    "type": "text",
                    "data": "N√£o h√° etapa anterior para regenerar."
                })
                return True
            
            output_messages.append({
                "type": "text",
                "data": f"üîÑ Regenerando conte√∫do para a Etapa {step_to_regenerate}..."
            })
            # N√£o avan√ßa o current_step, apenas for√ßa a re-execu√ß√£o da etapa anterior
            # O `executar_sistema` chamar√° a etapa correta novamente.
            # Limpa o resultado anterior para for√ßar a nova gera√ß√£o
            self.memoria[f'etapa{step_to_regenerate}_resultado'] = ''
            self.memoria[f'etapa{step_to_regenerate}_escolha'] = ''
            self.memoria[f'etapa{step_to_regenerate}_status'] = 'PENDENTE'
            self.memoria['last_ai_message_type'] = 'text' # Reseta o tipo de mensagem da IA
            self.memoria['last_ai_options'] = []
            self._save_project_state()
            return True
        
        # A√ß√£o de sele√ß√£o de idioma (na fase de conclus√£o)
        idiomas_siglas = ['pt', 'en', 'es', 'fr', 'de', 'uk'] # Adicione outras siglas se necess√°rio
        if self.current_step == 11 and user_input.upper() in [s.upper() for s in idiomas_siglas]:
            self.memoria['idioma_final_escolhido'] = user_input.upper()
            output_messages.append({
                "type": "text",
                "data": f"üåç Idioma para tradu√ß√£o selecionado: {user_input.upper()}."
            })
            self.current_step += 1 # Avan√ßa para a fase de conclus√£o
            self._save_project_state()
            return True

        return False # Nenhuma a√ß√£o reconhecida

    # ============================================================================
    # M√âTODOS DE PESQUISA SERPIAPI
    # ============================================================================

    def _pesquisar_seo_concorrentes(self, palavra_chave: str) -> Dict:
        """Pesquisa concorrentes no Google usando SerpiAPI"""
        
        cache_key = f"concorrentes_{palavra_chave}"
        if cache_key in self.cache_pesquisas:
            return self.cache_pesquisas[cache_key]
        
        try:
            logger.info(f"üîç SerpiAPI: Pesquisando '{palavra_chave}'...")
            
            params = {
                'api_key': self.serpi_api_key,
                'q': f'{palavra_chave} comprar {self.memoria["pais_venda"]}',
                'engine': 'google',
                'num': 10,
                'gl': self._obter_codigo_pais(),
                'hl': self._obter_idioma_pais()
            }
            
            response = requests.get('https://serpapi.com/search', params=params, timeout=30)
            data = response.json()
            
            concorrentes = []
            if 'organic_results' in data:
                for result in data['organic_results'][:8]:
                    concorrentes.append({
                        'titulo': result.get('title', ''),
                        'link': result.get('link', ''),
                        'snippet': result.get('snippet', ''),
                        'position': result.get('position', 0),
                        'dominio': urllib.parse.urlparse(result.get('link', '')).netloc
                    })
            
            insights = {
                'concorrentes_principais': concorrentes,
                'total_resultados': data.get('search_information', {}).get('total_results', 0),
                'queries_relacionadas': data.get('related_questions', [])[:5]
            }
            
            self.cache_pesquisas[cache_key] = insights
            return insights
            
        except Exception as e:
            logger.error(f"‚ùå Erro SerpiAPI: {str(e)}")
            return {'concorrentes_principais': [], 'total_resultados': 0, 'queries_relacionadas': []}

    def _analisar_serp_completa(self, palavra_chave: str) -> Dict:
        """An√°lise completa da SERP para insights avan√ßados"""
        
        try:
            logger.info(f"üìä SerpiAPI: An√°lise SERP completa...")
            
            variacoes = [palavra_chave, f'melhor {palavra_chave}', f'{palavra_chave} pre√ßo']
            resultados_serp = {}
            
            for variacao in variacoes:
                params = {
                    'api_key': self.serpi_api_key,
                    'q': variacao,
                    'engine': 'google',
                    'num': 5,
                    'gl': self._obter_codigo_pais()
                }
                
                response = requests.get('https://serpapi.com/search', params=params)
                data = response.json()
                
                resultados_serp[variacao] = {
                    'total_results': data.get('search_information', {}).get('total_results', 0),
                    'top_3_titulos': [r.get('title') for r in data.get('organic_results', [])[:3]]
                }
            
            return {'analise_variacoes': resultados_serp}
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è An√°lise SERP falhou: {str(e)}")
            return {}

    def _obter_codigo_pais(self) -> str:
        """Converte pa√≠s para c√≥digo do Google"""
        paises = {
            'brasil': 'br', 'brazil': 'br', 'eua': 'us', 'estados unidos': 'us',
            'espanha': 'es', 'spain': 'es', 'portugal': 'pt', 'fran√ßa': 'fr',
            'alemanha': 'de', 'germany': 'de'
        }
        return paises.get(self.memoria['pais_venda'].lower(), 'us')

    def _obter_idioma_pais(self) -> str:
        """Converte pa√≠s para idioma do Google"""
        idiomas = {
            'brasil': 'pt', 'brazil': 'pt', 'portugal': 'pt', 'espanha': 'es',
            'eua': 'en', 'estados unidos': 'en', 'fran√ßa': 'fr', 'alemanha': 'de'
        }
        return idiomas.get(self.memoria['pais_venda'].lower(), 'en')

    # ============================================================================
    # M√âTODOS DE EXTRA√á√ÉO E AN√ÅLISE
    # ============================================================================

    def _extrair_dados_produto(self, link_produto: str) -> Dict:
        """Extrai dados reais do produto usando web scraping"""
        
        try:
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
            response = requests.get(link_produto, headers=headers, timeout=10)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            title = soup.find('title')
            title_text = title.get_text().strip() if title else ""
            
            meta_desc = soup.find('meta', attrs={'name': 'description'})
            meta_desc_text = meta_desc['content'].strip() if meta_desc else ""
            
            return {
                'titulo_pagina': title_text,
                'meta_description': meta_desc_text,
                'url': link_produto,
                'metodo_extra√ß√£o': 'web_fetch',
                'qualidade': 'alta'
            }
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Web scraping falhou: {str(e)}")
            
            try:
                parsed_url = urllib.parse.urlparse(link_produto)
                path_parts = [p for p in parsed_url.path.split('/') if p]
                
                produto_nome = path_parts[-1].replace('-', ' ').title() if path_parts else "Produto"
                
                return {
                    'nome_produto': produto_nome,
                    'marketplace': parsed_url.netloc,
                    'metodo_extra√ß√£o': 'analise_url',
                    'qualidade': 'media'
                }
                
            except Exception as e2:
                logger.error(f"‚ùå An√°lise de URL falhou: {str(e2)}")
                
                nome_produto = "Produto Gen√©rico"
                categoria = "Geral"
                
                return {
                    'nome_produto': nome_produto,
                    'categoria': categoria,
                    'metodo_extra√ß√£o': 'coleta_manual',
                    'qualidade': 'baixa'
                }

    def _identificar_palavra_chave_principal(self, dados_produto: Dict) -> str:
        """Identifica a palavra-chave principal para SEO"""
        
        if dados_produto['metodo_extra√ß√£o'] == 'web_fetch':
            titulo = dados_produto.get('titulo_pagina', '')
            if titulo:
                palavras_remover = ['comprar', 'barato', 'oferta', 'melhor', 'online', 'loja']
                palavras = titulo.split()
                palavras_chave = [p for p in palavras if p.lower() not in palavras_remover]
                return ' '.join(palavras_chave[:4])
        
        return dados_produto.get('nome_produto', 'Produto Premium')

    def _apresentar_resumo_analise(self, dados_produto: Dict, palavra_chave: str, insights_pesquisa: Dict) -> Dict:
        """Apresenta resumo completo da an√°lise em formato JSON para o frontend"""
        
        resumo_text = "üìä RESUMO DA AN√ÅLISE PRELIMINAR\n\n"
        resumo_text += f"M√©todo Extra√ß√£o: {dados_produto['metodo_extra√ß√£o']}\n"
        resumo_text += f"Qualidade Dados: {dados_produto['qualidade']}\n"
        resumo_text += f"Palavra-chave Principal: {palavra_chave}\n"
        
        if dados_produto['metodo_extra√ß√£o'] == 'web_fetch':
            resumo_text += f"T√≠tulo P√°gina: {dados_produto.get('titulo_pagina', '')[:60]}...\n"
        else:
            resumo_text += f"Nome Produto: {dados_produto.get('nome_produto', '')}\n"
        
        concorrentes = insights_pesquisa.get('concorrentes', {}).get('concorrentes_principais', [])
        resumo_text += f"Concorrentes Encontrados: {len(concorrentes)}\n"
        
        return {
            "type": "text",
            "data": resumo_text
        }

    # ============================================================================
    # FLUXO DE ETAPAS (AGORA INCREMENTAL)
    # ============================================================================

    def _fase_1_analise_planejamento(self, output_messages: List[Dict]) -> Dict:
        """FASE 1: An√°lise preliminar e pesquisa SEO com SerpiAPI"""
        
        output_messages.append({
            "type": "text",
            "data": "üîç FASE 1: AN√ÅLISE E PLANEJAMENTO"
        })
        
        insights_pesquisa = {}
        
        # Extra√ß√£o inteligente do link
        output_messages.append({"type": "text", "data": "Extraindo dados do produto..."})
        dados_extraidos = self._extrair_dados_produto(self.memoria['link_produto'])
        self.memoria['dados_extraidos_do_link'] = dados_extraidos
        self._save_project_state()
        
        # Identifica√ß√£o da palavra-chave principal
        output_messages.append({"type": "text", "data": "Identificando palavra-chave principal..."})
        palavra_chave = self._identificar_palavra_chave_principal(dados_extraidos)
        self.memoria['palavra_chave_principal'] = palavra_chave
        self._save_project_state()
        
        # SERPIAPI - Pesquisa concorrentes
        output_messages.append({"type": "text", "data": "Pesquisando concorrentes no Google..."})
        insights_pesquisa['concorrentes'] = self._pesquisar_seo_concorrentes(palavra_chave)
        self._save_project_state()
        
        # SERPIAPI - An√°lise SERP completa
        output_messages.append({"type": "text", "data": "Analisando resultados Google..."})
        insights_pesquisa['serp'] = self._analisar_serp_completa(palavra_chave)
        self._save_project_state()
        
        # Salva insights da pesquisa na mem√≥ria para uso futuro
        self.memoria['insights_pesquisa'] = insights_pesquisa
        
        # Apresentar resumo
        output_messages.append(self._apresentar_resumo_analise(dados_extraidos, palavra_chave, insights_pesquisa))
        
        # Lista de etapas para o progresso
        etapas_list = [
            "T√≠tulo H2 da Cole√ß√£o", "Meta Title da Cole√ß√£o", "Meta Description da Cole√ß√£o",
            "Descri√ß√£o do Produto", "Meta Title do Produto", "Meta Description do Produto", 
            "Artigo Blog Shopify", "Artigo Blog Google SEO", "Legendas Redes Sociais",
            "Valida√ß√£o T√©cnica"
        ]
        
        # Avan√ßa para a pr√≥xima etapa (Etapa 1 de execu√ß√£o, que √© o current_step 2)
        self.current_step = 2
        self._save_project_state()
        
        output_messages.append({
            "type": "progress",
            "data": {
                "completed": ["Extra√ß√£o de Dados", "Pesquisa de Concorrentes", "An√°lise SERP"],
                "in_progress": f"Etapa {self.current_step - 1}: {etapas_list[self.current_step - 2]}",
                "upcoming": etapas_list[self.current_step - 1:]
            }
        })
        
        # Chama a primeira etapa de execu√ß√£o imediatamente
        return self._fase_2_execucao_etapas(output_messages)

    def _fase_2_execucao_etapas(self, output_messages: List[Dict]) -> Dict:
        """FASE 2: Execu√ß√£o das 9 etapas com OpenRouter, uma por vez."""
        
        insights_pesquisa = self.memoria.get('insights_pesquisa', {})
        
        etapas_map = {
            2: (self._etapa_1_titulo_h2_colecao, 'criativo', "Web Designer e Redator Criativo"),
            3: (self._etapa_2_meta_title_colecao, 'analise', "Especialista SEO e Growth Hacker"),
            4: (self._etapa_3_meta_description_colecao, 'criativo', "Especialista em Copywriting Persuasivo"),
            5: (self._etapa_4_descricao_produto, 'criativo', "Especialista em E-commerce e Marketing de Produto"),
            6: (self._etapa_5_meta_title_produto, 'analise', "Especialista em SEM e An√∫ncios Pagos"),
            7: (self._etapa_6_meta_description_produto, 'criativo', "Especialista em CRO (Conversion Rate Optimization)"),
            8: (self._etapa_7a_blog_shopify, 'criativo', "E-commerce Copywriter & Sales Conversion Specialist"),
            9: (self._etapa_7b_blog_google_seo, 'analise', "SEO Content Strategist & AI Search Optimization Expert"),
            10: (self._etapa_8_legendas_redes_sociais, 'criativo', "Social Media Strategist & AI Search Optimization Specialist"),
            # A etapa 9 (Valida√ß√£o T√©cnica) √© a √∫ltima etapa de gera√ß√£o de conte√∫do antes da tradu√ß√£o.
            # Ela ser√° chamada diretamente no _fase_3_conclusao_entrega para garantir que todos os conte√∫dos estejam prontos.
        }

        if self.current_step in etapas_map:
            func, modelo_chave, role = etapas_map[self.current_step]
            
            output_messages.append({"type": "text", "data": f"üéØ ETAPA {self.current_step - 1}/9: {role.upper()}"})
            
            # Se a etapa j√° foi gerada e aprovada, apenas avan√ßa
            if self.memoria.get(f'etapa{self.current_step - 1}_status') == 'APROVADO':
                output_messages.append({
                    "type": "text",
                    "data": f"Conte√∫do da Etapa {self.current_step - 1} j√° aprovado. Avan√ßando..."
                })
                self.current_step += 1
                self._save_project_state()
                return self._fase_2_execucao_etapas(output_messages) # Chama a pr√≥xima etapa
            
            # Gera o conte√∫do
            resultado, tokens_usados, modelo_usado = func(insights_pesquisa)
            self._salvar_na_memoria(str(self.current_step - 1), resultado, "PENDENTE", modelo_usado, tokens_usados)
            
            # Verifica se o resultado √© uma lista de op√ß√µes ou texto simples
            try:
                parsed_result = json.loads(resultado)
                if isinstance(parsed_result, list) and all('number' in item and 'content' in item for item in parsed_result):
                    output_messages.append({
                        "type": "options",
                        "data": parsed_result
                    })
                    self.memoria['last_ai_message_type'] = 'options'
                    self.memoria['last_ai_options'] = parsed_result
                    output_messages.append({
                        "type": "text",
                        "data": "Por favor, selecione uma das op√ß√µes digitando o n√∫mero correspondente, ou 'regenerar' para novas op√ß√µes."
                    })
                else:
                    # Se n√£o for uma lista de op√ß√µes, trata como texto
                    output_messages.append({
                        "type": "text",
                        "data": resultado
                    })
                    self.memoria['last_ai_message_type'] = 'text'
                    self.memoria['last_ai_options'] = []
                    output_messages.append({
                        "type": "text",
                        "data": "Por favor, digite 'aprovar' para continuar, ou 'regenerar' para refazer a etapa."
                    })
            except json.JSONDecodeError:
                # N√£o √© JSON, √© texto simples
                output_messages.append({
                    "type": "text",
                    "data": resultado
                })
                self.memoria['last_ai_message_type'] = 'text'
                self.memoria['last_ai_options'] = []
                output_messages.append({
                    "type": "text",
                    "data": "Por favor, digite 'aprovar' para continuar, ou 'regenerar' para refazer a etapa."
                })
            
            # Atualiza o progresso para o frontend
            etapas_list = [
                "T√≠tulo H2 da Cole√ß√£o", "Meta Title da Cole√ß√£o", "Meta Description da Cole√ß√£o",
                "Descri√ß√£o do Produto", "Meta Title do Produto", "Meta Description do Produto", 
                "Artigo Blog Shopify", "Artigo Blog Google SEO", "Legendas Redes Sociais",
                "Valida√ß√£o T√©cnica"
            ]
            completed_steps = [etapas_list[i-2] for i in range(2, self.current_step) if self.memoria.get(f'etapa{i-1}_status') == 'APROVADO']
            in_progress_step = etapas_list[self.current_step - 2] if self.current_step - 2 < len(etapas_list) else "Concluindo..."
            upcoming_steps = etapas_list[self.current_step - 1:]

            output_messages.append({
                "type": "progress",
                "data": {
                    "completed": completed_steps,
                    "in_progress": in_progress_step,
                    "upcoming": upcoming_steps
                }
            })
            return {"type": "structured_response", "messages": output_messages}
        
        elif self.current_step == 11: # Ap√≥s a etapa 10, vai para conclus√£o
            return self._fase_3_conclusao_entrega(output_messages)
        
        output_messages.append({
            "type": "error",
            "data": {"message": f"Etapa de execu√ß√£o {self.current_step - 1} n√£o implementada ou inv√°lida."}
        })
        self._save_project_state(new_status='error')
        return {"type": "structured_response", "messages": output_messages}

    def _fase_3_conclusao_entrega(self, output_messages: List[Dict]) -> Dict:
        """FASE 3: Conclus√£o, tradu√ß√£o e entrega HTML"""
        
        output_messages.append({
            "type": "text",
            "data": "üéâ FASE 3: CONCLUS√ÉO E ENTREGA"
        })
        
        idiomas = {'UK': 'Ingl√™s Brit√¢nico', 'FR': 'Franc√™s', 'DE': 'Alem√£o', 'ES': 'Espanhol', 'PT': 'Portugu√™s', 'EN': 'Ingl√™s'}
        idioma_escolhido = self.memoria.get('idioma_final_escolhido')
        
        if not idioma_escolhido:
            options = []
            for sigla, nome in idiomas.items():
                options.append({"number": len(options) + 1, "content": f"{sigla} - {nome}"})
            
            output_messages.append({
                "type": "options",
                "data": options
            })
            self.memoria['last_ai_message_type'] = 'options'
            self.memoria['last_ai_options'] = options
            output_messages.append({
                "type": "text",
                "data": "üåç Por favor, selecione o idioma para tradu√ß√£o digitando a sigla (ex: PT, EN, ES)."
            })
            return {"type": "structured_response", "messages": output_messages}

        output_messages.append({
            "type": "text",
            "data": f"üîÑ Traduzindo para {idiomas.get(idioma_escolhido, idioma_escolhido)}..."
        })

        # Gerar HTML final
        html_final = self._gerar_html_final(self.memoria, idioma_escolhido)
        
        output_messages.append({
            "type": "text",
            "data": "üöÄ ENTREGA FINAL CONCLU√çDA!\nSeu conte√∫do SEO premium est√° pronto para usar."
        })
        output_messages.append({
            "type": "html_content",
            "data": html_final,
            "filename": f"xpressseo_{self.memoria['palavra_chave_principal'].replace(' ', '_').lower()}_{idioma_escolhido}_{datetime.now().strftime('%Y%m%d_%H%M')}.html"
        })
        
        self.current_step = 12 # Marca como conclu√≠do
        self._save_project_state(new_status='completed')
        
        return {"type": "structured_response", "messages": output_messages}

    # ============================================================================
    # IMPLEMENTA√á√ÉO DAS 9 ETAPAS (CHAMADAS OPENROUTER)
    # ============================================================================

    def _etapa_1_titulo_h2_colecao(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 1: T√≠tulo H2 da Cole√ß√£o"""
        system_prompt = "Voc√™ √© um Web Designer e Redator Criativo. Combine criatividade na escrita com conhecimento t√©cnico em HTML responsivo."
        
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Pa√≠s de venda: {self.memoria.get('pais_venda', 'N/A')}
- Site: {self.memoria.get('nome_site_usuario', 'N/A')}

TAREFA: Crie uma frase para t√≠tulo H2 incluindo o nome da cole√ß√£o baseado na palavra-chave principal,
e adicione uma breve descri√ß√£o complementar (1-2 linhes).

FORMATO:
[T√≠tulo H2 Criativo e Atrativo]
*[Descri√ß√£o complementar breve e envolvente]*

EXEMPLO:
Cal√ßados Esportivos Premium: Performance e Estilo
*Descubra nossa cole√ß√£o exclusiva de cal√ßados esportivos premium, criados para unir conforto e tecnologia.*
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'criativo', system_prompt=system_prompt)

    def _etapa_2_meta_title_colecao(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 2: Meta Title da Cole√ß√£o"""
        system_prompt = "Voc√™ √© um Especialista SEO e Growth Hacker. Crie meta titles otimizados para cliques e ranqueamento."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Insights de Concorrentes: {json.dumps(insights_pesquisa.get('concorrentes', {}).get('concorrentes_principais', [])[:3], ensure_ascii=False)}
- Insights SERP: {json.dumps(insights_pesquisa.get('serp', {}).get('analise_variacoes', {}), ensure_ascii=False)}

TAREFA: Crie 5 op√ß√µes de Meta Titles para a cole√ß√£o, com no m√°ximo 60 caracteres cada.
Inclua a palavra-chave principal e use gatilhos de clique.
Retorne uma lista de objetos JSON, onde cada objeto tem 'number' e 'content'.

FORMATO:
[
  {{"number": 1, "content": "Meta Title 1"}},
  {{"number": 2, "content": "Meta Title 2"}},
  ...
]
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'analise', system_prompt=system_prompt)

    def _etapa_3_meta_description_colecao(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 3: Meta Description da Cole√ß√£o"""
        system_prompt = "Voc√™ √© um Especialista em Copywriting Persuasivo. Crie meta descriptions que incentivem o clique e resumam o conte√∫do."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Meta Title Escolhido (Etapa 2): {self.memoria.get('etapa2_escolha', 'N/A')}
- Insights de Concorrentes: {json.dumps(insights_pesquisa.get('concorrentes', {}).get('concorrentes_principais', [])[:3], ensure_ascii=False)}

TAREFA: Crie 5 op√ß√µes de Meta Descriptions para a cole√ß√£o, com no m√°ximo 160 caracteres cada.
Use a palavra-chave principal e o Meta Title escolhido como base.
Retorne uma lista de objetos JSON, onde cada objeto tem 'number' e 'content'.

FORMATO:
[
  {{"number": 1, "content": "Meta Description 1"}},
  {{"number": 2, "content": "Meta Description 2"}},
  ...
]
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'criativo', system_prompt=system_prompt)

    def _etapa_4_descricao_produto(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 4: Descri√ß√£o do Produto"""
        system_prompt = "Voc√™ √© um Especialista em E-commerce e Marketing de Produto. Crie descri√ß√µes de produto que vendam e informem."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Dados extra√≠dos do link: {json.dumps(self.memoria.get('dados_extraidos_do_link', {}), ensure_ascii=False)}

TAREFA: Crie uma descri√ß√£o completa e persuasiva para o produto.
Inclua:
- Um t√≠tulo atraente.
- Par√°grafos que destaquem benef√≠cios e caracter√≠sticas.
- Chamadas para a√ß√£o (CTAs).
- Use formata√ß√£o Markdown para facilitar a leitura (t√≠tulos, listas, negrito).
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'criativo', system_prompt=system_prompt)

    def _etapa_5_meta_title_produto(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 5: Meta Title do Produto"""
        system_prompt = "Voc√™ √© um Especialista em SEM e An√∫ncios Pagos. Crie meta titles para produtos que se destacam em resultados de busca e an√∫ncios."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Descri√ß√£o do Produto (Etapa 4): {self.memoria.get('etapa4_resultado', 'N/A')}

TAREFA: Crie 5 op√ß√µes de Meta Titles para a p√°gina do produto, com no m√°ximo 60 caracteres cada.
Foque em termos de busca e benef√≠cios diretos.
Retorne uma lista de objetos JSON, onde cada objeto tem 'number' e 'content'.

FORMATO:
[
  {{"number": 1, "content": "Meta Title Produto 1"}},
  {{"number": 2, "content": "Meta Title Produto 2"}},
  ...
]
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'analise', system_prompt=system_prompt)

    def _etapa_6_meta_description_produto(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 6: Meta Description do Produto"""
        system_prompt = "Voc√™ √© um Especialista em CRO (Conversion Rate Optimization). Crie meta descriptions que maximizem a taxa de cliques e a inten√ß√£o de compra."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Meta Title do Produto Escolhido (Etapa 5): {self.memoria.get('etapa5_escolha', 'N/A')}
- Descri√ß√£o do Produto (Etapa 4): {self.memoria.get('etapa4_resultado', 'N/A')}

TAREFA: Crie 5 op√ß√µes de Meta Descriptions para a p√°gina do produto, com no m√°ximo 160 caracteres cada.
Use o Meta Title e a descri√ß√£o do produto como base, focando em benef√≠cios e um CTA claro.
Retorne uma lista de objetos JSON, onde cada objeto tem 'number' e 'content'.

FORMATO:
[
  {{"number": 1, "content": "Meta Description Produto 1"}},
  {{"number": 2, "content": "Meta Description Produto 2"}},
  ...
]
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'criativo', system_prompt=system_prompt)

    def _etapa_7a_blog_shopify(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 7a: Artigo Blog Shopify (comercial)"""
        system_prompt = "Voc√™ √© um E-commerce Copywriter & Sales Conversion Specialist. Crie artigos de blog focados em vendas e convers√£o para plataformas como Shopify."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Descri√ß√£o do Produto (Etapa 4): {self.memoria.get('etapa4_resultado', 'N/A')}

TAREFA: Crie um artigo de blog curto (aprox. 300-500 palavras) focado em vendas para o produto.
O artigo deve ser otimizado para um blog de e-commerce (ex: Shopify), com foco em engajamento e convers√£o.
Inclua:
- T√≠tulo atraente.
- Introdu√ß√£o que capte a aten√ß√£o.
- Se√ß√µes que abordem problemas do cliente e como o produto resolve.
- Benef√≠cios e caracter√≠sticas do produto.
- CTA claro para a p√°gina do produto.
- Use formata√ß√£o Markdown.
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'criativo', system_prompt=system_prompt)

    def _etapa_7b_blog_google_seo(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 7b: Artigo Blog Google SEO (informativo)"""
        system_prompt = "Voc√™ √© um SEO Content Strategist & AI Search Optimization Expert. Crie artigos de blog informativos e aprofundados, otimizados para ranqueamento no Google."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Insights SERP: {json.dumps(insights_pesquisa.get('serp', {}).get('analise_variacoes', {}), ensure_ascii=False)}
- Queries Relacionadas: {json.dumps(insights_pesquisa.get('concorrentes', {}).get('queries_relacionadas', []), ensure_ascii=False)}

TAREFA: Crie um artigo de blog mais longo (aprox. 500-800 palavras) focado em SEO para o produto.
O artigo deve ser informativo, responder a d√∫vidas comuns e usar a palavra-chave principal e termos relacionados de forma natural.
Inclua:
- T√≠tulo otimizado para SEO.
- Estrutura com H1, H2, H3.
- Conte√∫do aprofundado que cubra aspectos relevantes do produto e seu nicho.
- Responda a algumas das "queries relacionadas".
- Use formata√ß√£o Markdown.
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'analise', system_prompt=system_prompt)

    def _etapa_8_legendas_redes_sociais(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 8: Legendas Redes Sociais"""
        system_prompt = "Voc√™ √© um Social Media Strategist & AI Search Optimization Specialist. Crie legendas de redes sociais que gerem engajamento e tr√°fego."
        prompt = f"""
CONTEXTO DO PRODUTO:
- Nome do produto: {self.memoria.get('dados_extraidos_do_link', {}).get('nome_produto', 'N/A')}
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- Descri√ß√£o do Produto (Etapa 4): {self.memoria.get('etapa4_resultado', 'N/A')}

TAREFA: Crie 5 op√ß√µes de legendas para redes sociais (Instagram, Facebook, TikTok) para o produto.
Cada legenda deve ser √∫nica, com emojis, hashtags relevantes e um CTA.
Retorne uma lista de objetos JSON, onde cada objeto tem 'number' e 'content'.

FORMATO:
[
  {{"number": 1, "content": "Legenda 1"}},
  {{"number": 2, "content": "Legenda 2"}},
  ...
]
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'criativo', system_prompt=system_prompt)

    def _etapa_9_validacao_tecnica(self, insights_pesquisa: Dict) -> Tuple[str, int, str]:
        """Etapa 9: Valida√ß√£o T√©cnica (ser√° a √∫ltima etapa de gera√ß√£o antes da tradu√ß√£o)"""
        system_prompt = "Voc√™ √© um Especialista em SEO T√©cnico. Analise o conte√∫do gerado para conformidade com as melhores pr√°ticas de SEO t√©cnico."
        prompt = f"""
CONTEXTO DO PROJETO:
- Palavra-chave principal: {self.memoria.get('palavra_chave_principal', 'N/A')}
- T√≠tulo H2 da Cole√ß√£o: {self.memoria.get('etapa1_escolha', 'N/A')}
- Meta Title da Cole√ß√£o: {self.memoria.get('etapa2_escolha', 'N/A')}
- Meta Description da Cole√ß√£o: {self.memoria.get('etapa3_escolha', 'N/A')}
- Descri√ß√£o do Produto: {self.memoria.get('etapa4_resultado', 'N/A')}
- Meta Title do Produto: {self.memoria.get('etapa5_escolha', 'N/A')}
- Meta Description do Produto: {self.memoria.get('etapa6_escolha', 'N/A')}
- Artigo Blog Shopify: {self.memoria.get('etapa7a_resultado', 'N/A')[:500]}...
- Artigo Blog Google SEO: {self.memoria.get('etapa7b_resultado', 'N/A')[:500]}...
- Legendas Redes Sociais: {self.memoria.get('etapa8_escolha', 'N/A')}

TAREFA: Realize uma valida√ß√£o t√©cnica de SEO para todo o conte√∫do gerado.
Verifique:
- Uso adequado da palavra-chave principal e varia√ß√µes.
- Otimiza√ß√£o para ranqueamento e cliques.
- Coer√™ncia e relev√¢ncia do conte√∫do.
- Sugira melhorias t√©cnicas se necess√°rio.
- Forne√ßa um score geral de 0 a 100.
- Use formata√ß√£o Markdown.
"""
        return self.openrouter_client.gerar_conteudo(prompt, 'tecnico', system_prompt=system_prompt)

    # ============================================================================
    # MODO AN√ÅLISE GSC - IMPLEMENTA√á√ÉO FUTURA
    # ============================================================================

    def _executar_analise_gsc(self):
        """Executa an√°lise completa de relat√≥rio GSC"""
        # Implementa√ß√£o futura
        pass

    # ============================================================================
    # M√âTODOS AUXILIARES
    # ============================================================================

    def _salvar_na_memoria(self, etapa: str, conteudo: str, status: str = "APROVADO", 
                           llm_usada: str = "", tokens_usados: int = 0):
        """Salva conte√∫do na mem√≥ria, incluindo LLM usada e tokens."""
        variaveis_etapa = {
            '1': 'etapa1_resultado', '2': 'etapa2_resultado', '3': 'etapa3_resultado',
            '4': 'etapa4_resultado', '5': 'etapa5_resultado', '6': 'etapa6_resultado',
            '7a': 'etapa7a_resultado', '7b': 'etapa7b_resultado', '8': 'etapa8_resultado',
            '9': 'etapa9_resultado'
        }
        
        if etapa in variaveis_etapa:
            self.memoria[variaveis_etapa[etapa]] = conteudo
            self.memoria[f'etapa{etapa}_status'] = status
            self.memoria[f'etapa{etapa}_llm_usada'] = llm_usada
            self.memoria[f'etapa{etapa}_tokens_usados'] = tokens_usados
            self._save_project_state() # Salva no Supabase ap√≥s cada atualiza√ß√£o da mem√≥ria

    def _gerar_html_final(self, resultados: Dict, idioma: str) -> str:
        """Gera HTML final responsivo com todos os resultados traduzidos."""
        
        # Traduzir os conte√∫dos gerados
        conteudos_traduzidos = {}
        
        # Primeiro, gera a valida√ß√£o t√©cnica (Etapa 9)
        validacao_tecnica_content, validacao_tokens, validacao_llm = self._etapa_9_validacao_tecnica(resultados.get('insights_pesquisa', {}))
        
        # Traduz a valida√ß√£o t√©cnica
        translated_validacao_tecnica, _, _ = self.openrouter_client.gerar_conteudo(
            prompt=f"Traduza para {idioma}: {validacao_tecnica_content}",
            modelo_chave='traducao',
            max_tokens=2000,
            system_prompt="Voc√™ √© um tradutor profissional. Traduza o texto fornecido para o idioma especificado, mantendo o contexto e o tom."
        )
        conteudos_traduzidos['etapa9_resultado'] = translated_validacao_tecnica
        self.memoria['etapa9_llm_usada'] = validacao_llm # Armazena LLM e tokens da valida√ß√£o
        self.memoria['etapa9_tokens_usados'] = validacao_tokens

        for i in range(1, 9): # Etapas 1 a 8
            key_resultado = f'etapa{i}_resultado'
            key_escolha = f'etapa{i}_escolha'
            
            conteudo_original = resultados.get(key_escolha) or resultados.get(key_resultado)
            if conteudo_original:
                # Se for uma lista de op√ß√µes, traduz cada op√ß√£o
                try:
                    parsed_content = json.loads(conteudo_original)
                    if isinstance(parsed_content, list):
                        translated_options = []
                        for item in parsed_content:
                            if 'content' in item:
                                translated_content, _, _ = self.openrouter_client.gerar_conteudo(
                                    prompt=f"Traduza para {idioma}: {item['content']}",
                                    modelo_chave='traducao',
                                    max_tokens=500,
                                    system_prompt="Voc√™ √© um tradutor profissional. Traduza o texto fornecido para o idioma especificado, mantendo o contexto e o tom."
                                )
                                translated_options.append({**item, 'content': translated_content})
                            else:
                                translated_options.append(item)
                        conteudos_traduzidos[key_escolha] = json.dumps(translated_options, ensure_ascii=False)
                    else:
                        # Se for texto simples, traduz
                        translated_content, _, _ = self.openrouter_client.gerar_conteudo(
                            prompt=f"Traduza para {idioma}: {conteudo_original}",
                            modelo_chave='traducao',
                            max_tokens=2000,
                            system_prompt="Voc√™ √© um tradutor profissional. Traduza o texto fornecido para o idioma especificado, mantendo o contexto e o tom."
                        )
                        conteudos_traduzidos[key_escolha] = translated_content
                except json.JSONDecodeError:
                    # N√£o √© JSON, √© texto simples
                    translated_content, _, _ = self.openrouter_client.gerar_conteudo(
                        prompt=f"Traduza para {idioma}: {conteudo_original}",
                        modelo_chave='traducao',
                        max_tokens=2000,
                        system_prompt="Voc√™ √© um tradutor profissional. Traduza o texto fornecido para o idioma especificado, mantendo o contexto e o tom."
                    )
                    conteudos_traduzidos[key_escolha] = translated_content
            else:
                conteudos_traduzidos[key_escolha] = 'Conte√∫do n√£o gerado ou n√£o aprovado.'
        
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>XpressSEO - {resultados.get('palavra_chave_principal', 'Relat√≥rio')}</title>
    <style>
        body {{ font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; background-color: #f4f4f4; }}
        .container {{ max-width: 900px; margin: 20px auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        h1, h2, h3 {{ color: #0056b3; }}
        h1 {{ text-align: center; margin-bottom: 30px; }}
        .section {{ margin-bottom: 25px; border-bottom: 1px solid #eee; padding-bottom: 20px; }}
        .section:last-child {{ border-bottom: none; }}
        pre {{ background: #e9e9e9; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; }}
        .meta-info {{ font-size: 0.9em; color: #666; text-align: center; margin-bottom: 20px; }}
        .llm-info {{ font-size: 0.8em; color: #888; margin-top: 5px; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Relat√≥rio SEO Completo - XpressSEO</h1>
        <p class="meta-info">Gerado em: {datetime.now().strftime('%d/%m/%Y %H:%M')} | Idioma: {idioma}</p>
        
        <div class="section">
            <h2>Informa√ß√µes do Projeto</h2>
            <p><strong>Produto:</strong> {resultados.get('link_produto', 'N/A')}</p>
            <p><strong>Palavra-chave Principal:</strong> {resultados.get('palavra_chave_principal', 'N/A')}</p>
            <p><strong>Pa√≠s de Venda:</strong> {resultados.get('pais_venda', 'N/A')}</p>
        </div>

        <div class="section">
            <h2>Etapa 1: T√≠tulo H2 da Cole√ß√£o</h2>
            <pre>{conteudos_traduzidos.get('etapa1_escolha', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa1_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa1_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 2: Meta Title da Cole√ß√£o</h2>
            <pre>{conteudos_traduzidos.get('etapa2_escolha', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa2_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa2_tokens_usados', 0)}</p>
        </div>
        
        <div class="section">
            <h2>Etapa 3: Meta Description da Cole√ß√£o</h2>
            <pre>{conteudos_traduzidos.get('etapa3_escolha', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa3_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa3_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 4: Descri√ß√£o do Produto</h2>
            <pre>{conteudos_traduzidos.get('etapa4_resultado', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa4_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa4_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 5: Meta Title do Produto</h2>
            <pre>{conteudos_traduzidos.get('etapa5_escolha', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa5_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa5_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 6: Meta Description do Produto</h2>
            <pre>{conteudos_traduzidos.get('etapa6_escolha', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa6_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa6_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 7a: Artigo Blog Shopify</h2>
            <pre>{conteudos_traduzidos.get('etapa7a_resultado', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa7a_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa7a_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 7b: Artigo Blog Google SEO</h2>
            <pre>{conteudos_traduzidos.get('etapa7b_resultado', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa7b_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa7b_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 8: Legendas Redes Sociais</h2>
            <pre>{conteudos_traduzidos.get('etapa8_escolha', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa8_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa8_tokens_usados', 0)}</p>
        </div>

        <div class="section">
            <h2>Etapa 9: Valida√ß√£o T√©cnica</h2>
            <pre>{conteudos_traduzidos.get('etapa9_resultado', 'Conte√∫do n√£o gerado.')}</pre>
            <p class="llm-info">LLM: {resultados.get('etapa9_llm_usada', 'N/A')} | Tokens: {resultados.get('etapa9_tokens_usados', 0)}</p>
        </div>

        <p style="text-align: center; margin-top: 30px; font-size: 0.8em; color: #999;">
            Desenvolvido por XpressSEO. Todos os direitos reservados.
        </p>
    </div>
</body>
</html>
"""
        return html_content


def main(
    project_id: str,
    user_id: str,
    user_message: str,
    current_step: int,
    supabase_url: str,
    supabase_key: str,
    openrouter_key: str,
    serpi_api_key: str,
    file_content: Optional[str] = None # Para futura implementa√ß√£o de GSC
) -> Dict:
    """
    XPRESS SEO MASTER - SISTEMA COMPLETO
    
    Args:
        project_id: ID do projeto Supabase
        user_id: ID do usu√°rio Supabase
        user_message: Mensagem do usu√°rio do frontend
        current_step: Etapa atual do workflow do projeto
        supabase_url: URL do Supabase
        supabase_key: Chave de servi√ßo do Supabase
        openrouter_key: Chave da API OpenRouter
        serpi_api_key: Chave da API SerpiAPI
        file_content: Conte√∫do do arquivo GSC (opcional, para modo GSC)
    """
    
    try:
        master = XpressSEOMaster(
            project_id=project_id,
            user_id=user_id,
            user_message=user_message,
            current_step=current_step,
            supabase_url=supabase_url,
            supabase_key=supabase_key,
            openrouter_key=openrouter_key,
            serpi_api_key=serpi_api_key
        )
        
        result = master.executar_sistema(arquivo_upload=file_content)
        
        logger.info("üéâ PROCESSO CONCLU√çDO COM SUCESSO!")
        
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Erro no sistema: {str(e)}")
        import traceback
        logger.error(f"üîç Detalhes: {traceback.format_exc()}")
        return {
            "type": "structured_response",
            "messages": [
                {
                    "type": "error",
                    "data": {"message": f"Erro interno do workflow: {str(e)}"}
                }
            ]
        }

# O bloco `if __name__ == "__main__":` n√£o ser√° executado no Windmill,
# pois o Windmill chama a fun√ß√£o `main` diretamente.
# Mantenho-o para fins de teste local, se necess√°rio, mas com valores mockados.
if __name__ == "__main__":
    # Exemplo de uso mockado para teste local
    # Estes valores seriam passados pela Edge Function do Supabase
    mock_project_id = "a1b2c3d4-e5f6-7890-1234-567890abcdef" # Substitua por um ID real ou crie um
    mock_user_id = "user123"
    mock_user_message = "https://www.exemplo.com/produto-teste-mock"
    mock_current_step = 0 # Inicia um novo workflow
    mock_supabase_url = os.getenv("SUPABASE_URL")
    mock_supabase_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY") # Use a service role key para testes
    mock_openrouter_key = os.getenv("OPENROUTER_API_KEY")
    mock_serpi_api_key = os.getenv("SERPI_API_KEY")

    if not all([mock_supabase_url, mock_supabase_key, mock_openrouter_key, mock_serpi_api_key]):
        print("Por favor, configure as vari√°veis de ambiente para testes locais.")
    else:
        print("Iniciando teste local do Windmill script...")
        result = main(
            project_id=mock_project_id,
            user_id=mock_user_id,
            user_message=mock_user_message,
            current_step=mock_current_step,
            supabase_url=mock_supabase_url,
            supabase_key=mock_supabase_key,
            openrouter_key=mock_openrouter_key,
            serpi_api_key=mock_serpi_api_key
        )
        print("\nResultado do teste local:")
        print(json.dumps(result, indent=2, ensure_ascii=False))